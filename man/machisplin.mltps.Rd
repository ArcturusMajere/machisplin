% Generated by roxygen2: do not edit by hand
% Please edit documentation in
%   R/ensemble.machine.learning.thin.plate.splines.V30.R
\name{machisplin.mltps}
\alias{machisplin.mltps}
\title{Machine Learning Ensemble & Thin-Plate-Spline Interpolation}
\usage{
machisplin.mltps(int.values, covar.ras, n.cores = 1, tps = TRUE)
}
\arguments{
\item{int.values}{An data frame with the first two columns as coordinates of interpolated site named exactly as 'long' and 'lat', in this order, and any number of layers to downscale- each as a new column}

\item{tps}{if tps=TRUE then the residuals of the best model will be interpolated using a thin-plate-spline and the final downscaled layer will be adjusted by this layer (this is what ANUSPLIN does)}

\item{covar.ras=}{a raster or raster stack of high-resolution raster layers at resolution and extent of downscaling.  These layers will be used as co-variates and careful consideration should be given properly selecting these.}

\item{ncores}{number of CPUs to use for interpolating - each core will be assigned a layer to interpolate. Best to first try with a few cores- this process can require a lot of memory}
}
\value{
This script interpolates noisy multi-variate data through machine learning ensembling using six algorithms: boosted regression trees (BRT), linear models; generalized additive model, multivariate adaptive regression splines (MARS), support vector machines (SVM) and random forests. This function evaluates (via k-fold cross validation, where k=10) a methodâ€™s ability to predict the input data and ensembles of all combinations of the six algorithms.  The best model will have the lowest AICc (with the number of parameters in AICc calculation corresponding the number of models in ensemble).  After the best model is determined, the function will run ensemble on the full dataset.  Then residuals will be calculated and interpolated using thin-plate-smoothing splines, which will secondarily correct the final ensemble model. This package is a free open-source machine learning analog to the expensive ANUSPLIN software. To output final R2 values, algorithm(s) used, and rasters for use in GIS; use the 'machisplin.write.geotiff' function
}
\description{
Machine Learning Ensemble & Thin-Plate-Spline Interpolation
}
\examples{
######## EXAMPLE 1 ########
library(MACHISPLIN)

# Import a csv as shapefile:
Mydata<-read.delim("sampling.csv", sep=",", h=T)

#load rasters to use as high resolution co-variates for downscaling
ALT = raster("SRTM30m.tif")
SLOPE = raster("ln_slope.tif")
ASPECT = raster("aspect.tif")
TWI = raster("TWI.tif")

# function input: raster brick of covarites
raster_stack<-stack(ALT,SLOPE,TWI,ASPECT)

#run an ensemble machine learning thin plate spline 
interp.rast<-machisplin.mltps(int.values=Mydata, covar.ras=raster_stack, n.cores=2)

######## EXAMPLE 2 ########
library(MACHISPLIN)
library(raster)

##load spatial data with (coordinates named exactly as 'long' and 'lat') and any number of layers to downscale
data(sampling)
Mydata<-sampling

#load rasters to use as high resolution co-variates for downscaling
ALT = raster(system.file("extdata", "alt.tif", package="MACHISPLIN"))
SLOPE = raster(system.file("extdata", "slope.tif", package="MACHISPLIN"))
TWI = raster(system.file("extdata", "TWI.tif", package="MACHISPLIN"))

# function input: raster brick of covarites
raster_stack<-stack(ALT,SLOPE,TWI)

#run an ensemble machine learning thin plate spline 
interp.rast<-machisplin.mltps(int.values=Mydata, covar.ras=raster_stack, n.cores=2)

machisplin.write.geotiff(mltps.in=interp.rast)
machisplin.write.residuals(mltps.in=interp.rast)
machisplin.write.loadings(mltps.in=interp.rast)
}
